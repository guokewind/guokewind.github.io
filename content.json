[{"title":"博客优化","date":"2017-02-14T17:15:30.000Z","path":"2017/02/15/开始使用多说/","text":"更新时间:2017年2月15日01:35:18 使用多说我使用的是yilia。 在_config.yml中添加多说的配置： duoshuo: 你站点的short_name 修改themes\\landscape\\layout\\_partial\\article.ejs 把&lt;section id=&quot;comments&quot;&gt;&lt;/section&gt;之间的代码换成多说的通用代码。 参考 一个人难免无聊，不知道谁会是我第一个评论者。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":" hexo中插入音乐","date":"2017-02-13T17:24:49.000Z","path":"2017/02/14/在hexo-yilia中使用网易云/","text":"前言从用QQ空间开始就喜欢插入背景音乐，如今自己管理自己的博客，当然也要插入音乐，不用开绿钻哈哈哈哈。 关于主题我用的是yilia。 添加音乐添加的网易云音乐，很方便。打开网易云音乐某首歌详情页，点击生成外链播放器，选择iframe插件。选择好尺寸。复制html代码。如：1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=298 height=52 src=&quot;//music.163.com/outchain/player?type=2&amp;id=4940455&amp;auto=1&amp;height=32&quot;&gt;&lt;/iframe&gt; 这里手动修改width为”100%”,再添上class。然后把下面这段代码复制到themes\\yilia\\layout\\_partial\\left-col.ejs里，代码： 123&lt;nav class=\"header-music\"&gt;&lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=298 height=52 src=\"//music.163.com/outchain/player?type=2&amp;id=4940455&amp;auto=1&amp;height=32\"&gt;&lt;/iframe&gt;&lt;/nav&gt; 如图: 。这样就可以生成播放器了，但是还需要调一下css样式。在themes\\yilia\\source\\main.2d7529.css(如果名字不同，也应为main.xx.css)末尾添加1.header-music &#123;margin-top: 80px; &#125; 接着hexo clean,hexo g,hexo s 搞定。效果如下： 之后会试着利用cplayer把列表插入到主题中。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"阿里巴巴Java规约学习-foreach","date":"2017-02-13T16:21:13.000Z","path":"2017/02/14/阿里巴巴Java规约学习-foreach/","text":"7. 【强制】不要在 foreach 循环里进行元素的 remove / add 操作。 remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。 反例： List&lt;String&gt; a = new ArrayList&lt;String&gt;(); a.add(&quot;1&quot;); a.add(&quot;2&quot;); for (String temp : a) { if(&quot;1&quot;.equals(temp)){ a.remove(temp); } } 说明：以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的 结果吗？ 正例： Iterator&lt;String&gt; it = a.iterator(); while(it.hasNext()){ String temp = it.next(); if(删除元素的条件){ it.remove(); } } 先看看输出结果: 123456789101112131415161718192021222324252627public class Test &#123; public static void main(String[] args) &#123; List&lt;String&gt; a = new ArrayList&lt;String&gt;(); a.add(\"1\"); a.add(\"2\");// for (String temp : a) &#123;// if (\"1\".equals(temp)) &#123;// a.remove(temp);//正常// &#125;// &#125; // for (String temp : a) &#123;// java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:859) at java.util.ArrayList$Itr.next(ArrayList.java:831)// if (\"2\".equals(temp)) &#123;// a.remove(temp);// &#125;// &#125; Iterator&lt;String&gt; it = a.iterator(); while (it.hasNext()) &#123; String temp = it.next(); if (\"1\".equals(temp)) &#123;//不论是1,2都正常 it.remove(); &#125; &#125; System.out.println(a.toString()); &#125;&#125; 为什么用foreach的时候，1没问题，2出错了呢？先从报错看异常是怎么出来的。由报错可知，是next方法中调用checkForComodification出错。 所以是modeCount !=expectedModCount导致的。 foreach是通过Iterable接口在序列中进行移动。 这里在foreach处打断点，进入可以知道： 赋值给temp的时候先new Itr()(仅第一次)，Itr对象再hasNext()判断，接着再调用next()赋值。 expectedModCount是初始化(此时生成一个Iterator对象)的时候被赋值的。而modCount又是AbstractList的变量。 每次调用list的add/remove的时候，modCount++，而这时它并没有传递给expectedModCount。 当第一次remove掉”2”后，modCount改变 ，for(String temp:a)的时候，会调用ArrayList$Itr.next()方法，next方法会检查modCount是否等于expectedModCount，所以用foreach的时候remove 2出错了。 foreach的时候remove 1没出错呢？稍微改下代码:1234567891011List&lt;String&gt; a = new ArrayList&lt;String&gt;(); a.add(\"1\"); a.add(\"2\"); int n=0; for (String temp : a) &#123;//正常,但是n为1，说明只有一次 n++;// System.out.println(n);//只输出1次:1 if (\"1\".equals(temp)) &#123; a.remove(temp); &#125; &#125; 输出结果:121[2] 可见,foreach 只执行了一次循环。 是什么导致本该两次的循环只进入了一次？之前说到foreach赋值的时候，会先先用hasNext判断。cursor！=size才进入循环体。这里的cursor指的是当前元素的index。循环体进入一次后，remove掉”1”，此时size由2变成了1，cursor也由于next后变为1。再次 for (String temp : a)的时候先调用hasNext因为其相等，所以不再进入循环体。 remove后size–: next后,cursor+1: hasNext比较 为什么直接用Iterator的remove是正常的？a.iterator()直接return new Itr()，Itr 实现了Iterator。我们看看Itr的remove方法： 这里明显看出当它remove后， 马上把modCount的值赋值到了expectedModCount上，所以不会出现list.remove那样报ConcurrentModificationException 。 当然如果并发操作，需要对 Iterator 对象加锁。 感谢阿里巴巴的Java规约~","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"开始使用hexo","date":"2017-02-13T15:40:41.000Z","path":"2017/02/13/开始使用hexo/","text":"被hexo的简洁、方便吸引。 今后会在这里记录我的点点滴滴。 谢谢。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://yoursite.com/tags/杂谈/"}]},{"title":"hexo命令报错","date":"2017-02-13T15:29:49.020Z","path":"2017/02/13/hexo错误/","text":"1YAMLException: end of the stream or a document separator is expected at line 26, column 1: 报错的行根本没有错。用排除法逐一删掉，再hexo g，结果发现是 作横线的 “———-“ 后面少了一个空格的原因,改成”———- “就好了。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]