[{"title":" 更换vps","date":"2017-03-21T17:38:17.000Z","path":"2017/03/22/更换vps/","text":"成文时间：2017-03-22 01:31:00更新时间：2017-03-29最近vultr有2.5美元一个月，还有活动，配置也不错。准备转移到vultr。长期有效的邀请链接。还是用搬瓦工,顺便广告：kvm,28$包年,512内存,目前4机房 , 19$包年,512mb内存，1机房,稳定好用。优惠码：IAMSMART5Q74B8（节省4.77%） 安装的是centos7,之前用的centos6，有些不同。记录下我的服务器配置 在确认配置好之前，先别关闭ssh，新开一个终端测试 SSH 更换端口用下面命令进入配置文件。 vi /etc/ssh/sshd_config 找到#port 22，将前面的#去掉，然后修改端口 port 20001（自己设定）建议先添加新端口，待新端口可以连接后再去掉22端口 然后重启ssh服务。 service sshd restart 开放20001端口 firewall-cmd --zone=public --add-port=20001/tcp --permanent 或者 iptables -A INPUT -p tcp -dport 20001 -j ACCEPT 如果是iptables，第一次配置先 iptables -F //清除所有的已订定的规则，如果清空后连不上，可能是预设规则为DROP，可通过iptable -nL查看 新建一个用户代替root//添加一个名为tommy的用户 adduser tommy passwd tommy //修改密码 获得root 权限： 修改 /etc/sudoers 文件，找到下面一行，在root下面添加一行，如下所示： ##Allow root to run any commands anywhere root ALL=(ALL) ALL tommy ALL=(ALL) ALL 修改完毕，现在可以用tommy帐号登录，然后用命令 su - ，即可获得root权限进行操作。 使用密钥登录使用xshell-工具-新建用户密钥生成向导,一直下一步，保存生成的公钥，私钥。把公钥复制保存到Linux服务器的authorized_keys文件里面。 需要把该信息拷贝到Linux服务器的特定文件中：~/.ssh/authroized_keys其中，“~”表示对应用户的主目录，以tommy为例。若.ssh目录不存在，请创建它，并把公钥信息写入文件中： mkdir ~/.ssh chmod 700 ~/.ssh vi ~/.ssh/authorized_keys chmod 600 ~/.ssh/authorized_keys 请务必留意：文件和目录的权限问题，用户必须是将要进行认证的用户，而权限必须是0644，也就是禁止其他人对该文件写入信息。（否则，某些有心人把自己的公钥写入这里，他也可以无密码进来了）因为，通常umask是0022或0002的，所以请使用chown和chmod修改为对应的权限咯。 基于密钥认证的配置由于这里是tommy在操作，所以需要获取权限才能操作 sudo vi /etc/ssh/sshd_config 修改为 PasswordAuthentication no //禁止使用基于口令认证的方式登陆 PubkeyAuthentication yes //允许使用基于密钥认证的方式登陆 重启ssh sudo service sshd restart 如果失败，可尝试kill -9 [sshd的pid]然后 sudo service sshd start 尝试登录，只能使用密匙登录。 用密匙登录，提示没有注册该密匙。 多次检查配置后，没有问题。查看/var/log/secure提示 Authentication refused: bad ownership or modes for directory /home/tommy/.ssh得知是权限设置错了 SSH doesn’t like it if your home or ~/.ssh directories have group write permissions. Your home directory should be writable only by you, ~/.ssh should be 700, and authorized_keys should be 600You can also get around this by adding StrictModes off to your ssh_config file, but I’d advise against it - fixing permissions is the way to go. 所以一定要改成： chmod 700 ~/.ssh chmod 600 ~/.ssh/authorized_keys 重启sshsudo service sshd start ,成功登录。 已经可以用tommy登录了，所以可以不允许root用户登录了: sudo vi /etc/ssh/sshd_config 修改为 PermitRootLogin no 今天就到这里了。。 继续配置iptables 只允许每个ip同时5个80端口转发,超过的丢弃 iptables -I FORWARD -p tcp --syn --dport 80 -m connlimit --connlimit-above 5 -j DROP 拒绝其他所有协议 不太清楚最好别运行。 iptables -A INPUT -j REJECT //!!在运行此规则之前先确保ssh端口已经生效（service iptables restart） 如果已经运行又断开了连接，试着重启一下服务器，只要没永久生效那么还能连上。 2017年4月25日更新：拖了一个月了。。 ##安装nginx ###需要下载的东西 1.nginx (下载：http://nginx.org/en/download.html )2.gzip 模块需要 zlib 库 ( 下载: http://www.zlib.net/ )3.rewrite 模块需要 pcre 库 ( 下载: http://www.pcre.org/ )4.ssl 功能需要 openssl 库 ( 下载: http://www.openssl.org/ )下载： wget http://nginx.org/download/nginx-1.10.3.tar.gz http://www.zlib.net/zlib-1.2.11.tar.gz https://ftp.pcre.org/pub/pcre/pcre2-10.23.tar.gz https://www.openssl.org/source/openssl-1.1.0e.tar.gz 解压： tar -zxvf nginx-1.10.3.tar.gz tar -zxvf zlib-1.2.11.tar.gz tar -zxvf pcre2-10.23.tar.gz tar -zxvf openssl-1.1.0e.tar.gz 依赖包安装顺序依次为:openssl、zlib、pcre, 然后安装Nginx包。 mv nginx-1.10.3 openssl-1.1.0e pcre2-10.21 zlib-1.2.11 /usr/local/ 编译安装openssl ： cd /usr/local/openssl-1.1.0e &amp;&amp; ./config &amp;&amp; make &amp;&amp; make install prce: cd /usr/local/pcre2-10.23 &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make install zlib: 如果安装失败，试着yum install gcc cd /usr/local/zlib-1.2.11 &amp;&amp; ./configure &amp;&amp; make &amp;&amp; make install nginx:(这里我安装了ssl模块) pcre别乱删除 cd /usr/local/nginx-1.10.3 &amp;&amp;./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module &amp;&amp; make &amp;&amp; make install 如果报错 ./configure: error: the HTTP rewrite module requires the PCRE library.解决： yum -y install pcre-devel 报错: ./configure: error: SSL modules require the OpenSSL library. yum -y install openssl openssl-devel 查看已经安装好的模块 /usr/local/nginx/sbin/nginx -V nginx version: nginx/1.10.3 提示下面的信息表示已经安装好了。 built by gcc 4.8.5 20150623 (Red Hat 4.8.5-11) (GCC) built with OpenSSL 1.0.1e-fips 11 Feb 2013 TLS SNI support enabled configure arguments: –prefix=/usr/local/nginx –with-http_stub_status_module –with-http_ssl_module ssl证书我使用的腾讯的一年免费证书。 参考 2.1 获取证书 Nginx文件夹内获得SSL证书文件 1_www.domain.com_bundle.crt 和私钥文件 2_www.domain.com.key,1_www.domain.com_bundle.crt 文件包括两段证书代码 “—–BEGIN CERTIFICATE—–”和“—–END CERTIFICATE—–”,2_www.domain.com.key 文件包括一段私钥代码“—–BEGIN RSA PRIVATE KEY—–”和“—–END RSA PRIVATE KEY—–”。 2.2 证书安装 将域名 www.domain.com 的证书文件1_www.domain.com_bundle.crt 、私钥文件2_www.domain.com.key保存到同一个目录，例如/usr/local/nginx/conf目录下。更新Nginx根目录下 conf/nginx.conf 文件如下： server { listen 443; server_name www.domain.com; #填写绑定证书的域名 ssl on; ssl_certificate 1_www.domain.com_bundle.crt; ssl_certificate_key 2_www.domain.com.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置 ssl_prefer_server_ciphers on; location / { root html; #站点目录 index index.html index.htm; } }配置完成后，先用bin/nginx –t来测试下配置是否有误，正确无误的话，重启nginx。就可以使 https://www.domain.com 来访问了。 注： 配置文件参数 说明listen 443 SSL访问端口号为443ssl on 启用SSL功能ssl_certificate 证书文件ssl_certificate_key 私钥文件ssl_protocols 使用的协议ssl_ciphers 配置加密套件，写法遵循openssl标准2.3 使用全站加密，http自动跳转https（可选） 对于用户不知道网站可以进行https访问的情况下，让服务器自动把http的请求重定向到https。在服务器这边的话配置的话，可以在页面里加js脚本，也可以在后端程序里写重定向，当然也可以在web服务器来实现跳转。Nginx是支持rewrite的（只要在编译的时候没有去掉pcre）在http的server里增加rewrite ^(.*) https://$host$1 permanent;这样就可以实现80进来的请求，重定向为https了。","tags":[{"name":"vps","slug":"vps","permalink":"http://yoursite.com/tags/vps/"},{"name":"搬瓦工","slug":"搬瓦工","permalink":"http://yoursite.com/tags/搬瓦工/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"vultr","slug":"vultr","permalink":"http://yoursite.com/tags/vultr/"},{"name":"centos","slug":"centos","permalink":"http://yoursite.com/tags/centos/"}]},{"title":"使用https","date":"2017-02-16T17:24:04.000Z","path":"2017/02/17/使用https/","text":"成文时间: 2017年2月17日 01:25:15 使用https看到访问地址，好像缺点什么。htpps，就是它。 在阿里云上申请了一年的免费SSL证书，需要在服务器特定路径上传一个文件用以验证。这里引用了阿里云的安装介绍。 ( 1 ) 在Nginx的安装目录下创建cert目录，并且将下载的全部文件拷贝到cert目录中。如果申请证书时是自己创建的CSR文件，请将对应的私钥文件放到cert目录下并且命名为cert.key； ( 2 ) 打开 Nginx 安装目录下 conf 目录中的 nginx.conf 文件，找到： server { listen 443; server_name localhost; ssl on; ssl_certificate cert.pem; ssl_certificate_key cert.key; ssl_session_timeout 5m; ssl_protocols SSLv2 SSLv3 TLSv1; ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP; ssl_prefer_server_ciphers on; location / { root html } } ( 3 ) 将其修改为 (以下属性中ssl开头的属性与证书配置有直接关系，其它属性请结合自己的实际情况复制或调整) : 保存退出。 ( 4 )重启 Nginx。 ( 5 ) 通过 https 方式访问您的站点，测试站点证书的安装配置。 也可以不新开一个server， 直接在之前的server上 server { listen 80; listen 443 ssl; server_name localhost; ssl_certificate cert.pem; ssl_certificate_key cert.key; ssl_session_timeout 5m; ssl_protocols SSLv2 SSLv3 TLSv1; ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP; ssl_prefer_server_ciphers on; location / { root html } #这样可以强制https if ($scheme = http ) { return 301 https://$host$request_uri; } } 启动后，访问报错了。查询后发现是用了SSL却没有安装http_ssl_module模块，但http_ssl_module并不属于nginx的基本模块所以自己重新编译添加。 1.首先看下内核和系统的版本号。[root@zabbix ~]# uname -aLinux zabbix.nnkj.com 2.6.32-573.el6.x86_64 #1 SMP Thu Jul 23 15:44:03 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux[root@zabbix ~]# cat /etc/issueCentOS release 6.7 (Final)Kernel \\r on an \\m 2.看下编译安装nginx的时候，都编译安装的哪些模块。[root@zabbix ~]# /usr/local/nginx/sbin/nginx -Vnginx version: nginx/1.8.0built by gcc 4.4.7 20120313 (Red Hat 4.4.7-17) (GCC)built with OpenSSL 1.0.1e-fips 11 Feb 2013TLS SNI support enabledconfigure arguments: –prefix=/usr/local/nginx 3.进入之前下载并解压了的源码包目录；重新编译nginx注意- –prefix=PATH: 指定nginx的安装目录 ，这里要指定为之前的prefix[root@zabbix nginx-1.8.0]# cd /usr/local/src/nginx-1.8.0[root@zabbix nginx-1.8.0]# ./configure –prefix=/usr/local/nginx –with-http_stub_status_module –with-http_ssl_module[root@zabbix nginx-1.8.0]# make▲这一步千万不能 make install ；不然会把之前已经安装的nginx 覆盖掉 4.需要替换nginx二进制文件,先停止掉nginx进程；备份一下原来的启动脚本。[root@zabbix nginx-1.8.0]# /etc/init.d/nginx stop[root@zabbix nginx-1.8.0]# cp /etc/init.d/nginx /etc/init.d/nginx.bak [root@zabbix nginx-1.8.0]# cp objs/nginx /usr/local/nginx/sbin/cp: overwrite `/usr/local/nginx/sbin/nginx’? yes 5.查看nginx的模块，看下是否把需要的模块编译进去了 参考:http://www.itnpc.com/news/web/146771636486934.html 重启后，访问成功了，不过我这里提示有不受信任的资源，应该是引用了不少外部链接的原因吧。对了，我的地址。","tags":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"},{"name":"https","slug":"https","permalink":"http://yoursite.com/tags/https/"},{"name":"ssl","slug":"ssl","permalink":"http://yoursite.com/tags/ssl/"}]},{"title":"博客优化","date":"2017-02-14T17:15:30.000Z","path":"2017/02/15/博客优化/","text":"更新时间:2017年2月15日01:35:18 使用多说我使用的是yilia。 在_config.yml中添加多说的配置： duoshuo: 你站点的short_name 修改themes\\landscape\\layout\\_partial\\article.ejs 把&lt;section id=&quot;comments&quot;&gt;&lt;/section&gt;之间的代码换成多说的通用代码。 参考 一个人难免无聊，不知道谁会是我第一个评论者。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":" hexo中插入音乐","date":"2017-02-13T17:24:49.000Z","path":"2017/02/14/在hexo-yilia中使用网易云/","text":"前言从用QQ空间开始就喜欢插入背景音乐，如今自己管理自己的博客，当然也要插入音乐，不用开绿钻哈哈哈哈。 关于主题我用的是yilia。 添加音乐添加的网易云音乐，很方便。打开网易云音乐某首歌详情页，点击生成外链播放器，选择iframe插件。选择好尺寸。复制html代码。如：1&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=298 height=52 src=&quot;//music.163.com/outchain/player?type=2&amp;id=4940455&amp;auto=1&amp;height=32&quot;&gt;&lt;/iframe&gt; 这里手动修改width为”100%”,再添上class。然后把下面这段代码复制到themes\\yilia\\layout\\_partial\\left-col.ejs里，代码： 123&lt;nav class=\"header-music\"&gt;&lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=298 height=52 src=\"//music.163.com/outchain/player?type=2&amp;id=4940455&amp;auto=1&amp;height=32\"&gt;&lt;/iframe&gt;&lt;/nav&gt; 如图: 。这样就可以生成播放器了，但是还需要调一下css样式。在themes\\yilia\\source\\main.2d7529.css(如果名字不同，也应为main.xx.css)末尾添加1.header-music &#123;margin-top: 80px; &#125; 接着hexo clean,hexo g,hexo s 搞定。效果如下： 之后会试着利用cplayer把列表插入到主题中。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"阿里巴巴Java规约学习-foreach","date":"2017-02-13T16:21:13.000Z","path":"2017/02/14/阿里巴巴Java规约学习-foreach/","text":"7. 【强制】不要在 foreach 循环里进行元素的 remove / add 操作。 remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。 反例： List&lt;String&gt; a = new ArrayList&lt;String&gt;(); a.add(&quot;1&quot;); a.add(&quot;2&quot;); for (String temp : a) { if(&quot;1&quot;.equals(temp)){ a.remove(temp); } } 说明：以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的 结果吗？ 正例： Iterator&lt;String&gt; it = a.iterator(); while(it.hasNext()){ String temp = it.next(); if(删除元素的条件){ it.remove(); } } 先看看输出结果: 123456789101112131415161718192021222324252627public class Test &#123; public static void main(String[] args) &#123; List&lt;String&gt; a = new ArrayList&lt;String&gt;(); a.add(\"1\"); a.add(\"2\");// for (String temp : a) &#123;// if (\"1\".equals(temp)) &#123;// a.remove(temp);//正常// &#125;// &#125; // for (String temp : a) &#123;// java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:859) at java.util.ArrayList$Itr.next(ArrayList.java:831)// if (\"2\".equals(temp)) &#123;// a.remove(temp);// &#125;// &#125; Iterator&lt;String&gt; it = a.iterator(); while (it.hasNext()) &#123; String temp = it.next(); if (\"1\".equals(temp)) &#123;//不论是1,2都正常 it.remove(); &#125; &#125; System.out.println(a.toString()); &#125;&#125; 为什么用foreach的时候，1没问题，2出错了呢？先从报错看异常是怎么出来的。由报错可知，是next方法中调用checkForComodification出错。 所以是modeCount !=expectedModCount导致的。 foreach是通过Iterable接口在序列中进行移动。 这里在foreach处打断点，进入可以知道： 赋值给temp的时候先new Itr()(仅第一次)，Itr对象再hasNext()判断，接着再调用next()赋值。 expectedModCount是初始化(此时生成一个Iterator对象)的时候被赋值的。而modCount又是AbstractList的变量。 每次调用list的add/remove的时候，modCount++，而这时它并没有传递给expectedModCount。 当第一次remove掉”2”后，modCount改变 ，for(String temp:a)的时候，会调用ArrayList$Itr.next()方法，next方法会检查modCount是否等于expectedModCount，所以用foreach的时候remove 2出错了。 foreach的时候remove 1没出错呢？稍微改下代码:1234567891011List&lt;String&gt; a = new ArrayList&lt;String&gt;(); a.add(\"1\"); a.add(\"2\"); int n=0; for (String temp : a) &#123;//正常,但是n为1，说明只有一次 n++;// System.out.println(n);//只输出1次:1 if (\"1\".equals(temp)) &#123; a.remove(temp); &#125; &#125; 输出结果:121[2] 可见,foreach 只执行了一次循环。 是什么导致本该两次的循环只进入了一次？之前说到foreach赋值的时候，会先先用hasNext判断。cursor！=size才进入循环体。这里的cursor指的是当前元素的index。循环体进入一次后，remove掉”1”，此时size由2变成了1，cursor也由于next后变为1。再次 for (String temp : a)的时候先调用hasNext因为其相等，所以不再进入循环体。 remove后size–: next后,cursor+1: hasNext比较 为什么直接用Iterator的remove是正常的？a.iterator()直接return new Itr()，Itr 实现了Iterator。我们看看Itr的remove方法： 这里明显看出当它remove后， 马上把modCount的值赋值到了expectedModCount上，所以不会出现list.remove那样报ConcurrentModificationException 。 当然如果并发操作，需要对 Iterator 对象加锁。 感谢阿里巴巴的Java规约~","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"开始使用hexo","date":"2017-02-13T15:40:41.000Z","path":"2017/02/13/开始使用hexo/","text":"被hexo的简洁、方便吸引。 今后会在这里记录我的点点滴滴。 谢谢。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://yoursite.com/tags/杂谈/"}]},{"title":"hexo命令报错","date":"2017-02-13T15:29:49.020Z","path":"2017/02/13/hexo错误/","text":"1YAMLException: end of the stream or a document separator is expected at line 26, column 1: 报错的行根本没有错。用排除法逐一删掉，再hexo g，结果发现是 作横线的 “———-“ 后面少了一个空格的原因,改成”———- “就好了。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]